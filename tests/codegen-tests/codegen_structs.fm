//// Basic struct with member access - now with inline function
//t(
//"struct foo {\n"
//"    let x: i32 = 123;\n"
//"    fn get_x() -> i32 { return x; }\n"
//"};\n"
//"fn main() -> i32 {\n"
//"    let var = foo{69};\n"
//"    return var.get_x();\n"
//"}\n"
//,pass),
//
//// Basic member function with implicit 'this' access - with pointer usage and external definition
//t(
//"struct point {\n"
//"    let x: i32 = 0;\n"
//"    let y: i32 = 0;\n"
//"    fn get_y() -> i32 { return y; }\n"
//"    fn get_y_ptr() -> i32*;\n"
//"};\n"
//"fn point::get_y_ptr() -> i32* { return &y; }\n"
//"fn main() -> i32 {\n"
//"    let p: point = {10, 69};\n"
//"    let y_ptr: i32* = p.get_y_ptr();\n"
//"    let result: i32 = *y_ptr;\n"
//"    return result;\n"
//"}\n"
//,pass),
//
//// Member function calling another member function - with postfix chaining and mixed definitions
//t(
//"struct calculator {\n"
//"    let value: i32 = 0;\n"
//"    fn get_value() -> i32 { return value; }\n"
//"    fn double() -> i32;\n"
//"    fn triple() -> i32 { return get_value() * 3; }\n"
//"};\n"
//"fn calculator::double() -> i32 { return get_value() * 2; }\n"
//"fn main() -> i32 {\n"
//"    let calc: calculator = {34};\n"
//"    let calc_ptr: calculator* = &calc;\n"
//"    let result: i32 = calc_ptr->double();\n"
//"    return result + 1;\n"
//"}\n"
//,pass),
//
//// Member function modifying member variable - with pointer access and external definition
//t(
//"struct counter {\n"
//"    let count: i32 = 0;\n"
//"    fn increment() -> void;\n"
//"    fn get_count() -> i32 { return count; }\n"
//"    fn get_count_ptr() -> i32*;\n"
//"};\n"
//"fn counter::increment() -> void {\n"
//"    count = count + 1;\n"
//"}\n"
//"fn counter::get_count_ptr() -> i32* { return &count; }\n"
//"fn main() -> i32 {\n"
//"    let c: counter = {68};\n"
//"    let c_ptr: counter* = &c;\n"
//"    c_ptr->increment();\n"
//"    let count_ptr: i32* = c_ptr->get_count_ptr();\n"
//"    return *count_ptr;\n"
//"}\n"
//,pass),
//
//// Namespaced structs with mixed inline/external definitions
//t(
//"namespace math {\n"
//"    struct vector {\n"
//"        let x: i32 = 0;\n"
//"        let y: i32 = 0;\n"
//"        fn magnitude_squared() -> i32 { return x*x + y*y; }\n"
//"        fn set_x(new_x: i32) -> void;\n"
//"        fn get_x_ptr() -> i32* { return &x; }\n"
//"    };\n"
//"}\n"
//"fn math::vector::set_x(new_x: i32) -> void { x = new_x; }\n"
//"fn main() -> i32 {\n"
//"    let v: math::vector = {3, 4};\n"
//"    let v_ptr: math::vector* = &v;\n"
//"    v_ptr->set_x(5);\n"
//"    let x_ptr: i32* = v_ptr->get_x_ptr();\n"
//"    *x_ptr = 6;\n"
//"    return v_ptr->magnitude_squared();\n"
//"}\n"
//,pass),
//
//// Nested namespaces with postfix chaining
//t(
//"namespace graphics {\n"
//"    namespace shapes {\n"
//"        struct circle {\n"
//"            let radius: i32 = 0;\n"
//"            fn get_radius() -> i32 { return radius; }\n"
//"            fn get_area_approx() -> i32;\n"
//"            fn get_radius_ptr() -> i32* { return &radius; }\n"
//"        };\n"
//"    };\n"
//"}\n"
//"fn graphics::shapes::circle::get_area_approx() -> i32 {\n"
//"    return get_radius() * get_radius() * 3;\n"
//"}\n"
//"fn main() -> i32 {\n"
//"    let c: graphics::shapes::circle = {5};\n"
//"    let c_ptr: graphics::shapes::circle* = &c;\n"
//"    let radius_ptr: i32* = c_ptr->get_radius_ptr();\n"
//"    *radius_ptr = 10;\n"
//"    return c_ptr->get_area_approx();\n"
//"}\n"
//,pass),
//
// Struct with pointer members and complex postfix expressions
t(
"struct node {\n"
"    let value: i32 = 0;\n"
"    let value_ptr: i32*;\n"
"    let next: node* = {2};\n"
"    fn get_next() -> node { return *next; }\n"
"    fn set_next(n: node*) -> void { next = n; }\n"
"};\n"
"fn main() -> i32 {\n"
"    let nodea: node;\n"
"    let node1 = node {10};\n"
"    let var = {123};\n"
"    node1.next = {1};\n"
"    let node2 = node {20};\n"
"    let node3 = node {30};\n"
"    node1.set_next(&node2);\n"
"    node2.set_next(&node3);\n"
"    *node1.get_next().value_ptr = 69;\n"
"    return *node1.get_next().value_ptr;\n"
"}\n"
,pass),
//
//// Testing member function on temporary (should fail)
//t(
//"namespace factory {\n"
//"    struct product {\n"
//"        let id: i32 = 0;\n"
//"        fn get_id() -> i32 { return id; }\n"
//"    };\n"
//"    struct factory {\n"
//"        fn create(id: i32) -> product { return product{id}; }\n"
//"        fn process(p: product*) -> i32;\n"
//"    };\n"
//"}\n"
//"fn factory::factory::process(p: product*) -> i32 { return p->get_id(); }\n"
//"fn main() -> i32 {\n"
//"    let f: factory::factory = {};\n"
//"    return f.create(42).get_id();\n"
//"}\n"
//,fail),
//
//// Complex nested struct with pointers and postfix
//t(
//"namespace container {\n"
//"    struct inner {\n"
//"        let data: i32 = 0;\n"
//"        fn get_data() -> i32 { return data; }\n"
//"        fn modify_data(delta: i32) -> void;\n"
//"    };\n"
//"    struct outer {\n"
//"        let inner_obj: inner = {};\n"
//"        let inner_ptr: inner* = {};\n"
//"        fn init() -> void { inner_ptr = &inner_obj; }\n"
//"        fn get_inner_via_ptr() -> inner*;\n"
//"        fn cascade_modify(delta: i32) -> i32;\n"
//"    };\n"
//"}\n"
//"fn container::inner::modify_data(delta: i32) -> void { data = data + delta; }\n"
//"fn container::outer::get_inner_via_ptr() -> inner* { return inner_ptr; }\n"
//"fn container::outer::cascade_modify(delta: i32) -> i32 {\n"
//"    inner_ptr->modify_data(delta);\n"
//"    return inner_ptr->get_data();\n"
//"}\n"
//"fn main() -> i32 {\n"
//"    let outer_obj: container::outer = {{42}};\n"
//"    let outer_ptr: container::outer* = &outer_obj;\n"
//"    outer_ptr->init();\n"
//"    return outer_ptr->get_inner_via_ptr()->get_data();\n"
//"}\n"
//,pass),
//
//// Testing invalid member access without instance
//t(
//"namespace test {\n"
//"    struct data {\n"
//"        let value: i32 = 0;\n"
//"        fn get_value() -> i32;\n"
//"    };\n"
//"}\n"
//"fn test::data::get_value() -> i32 { return value; }\n"
//"fn main() -> i32 {\n"
//"    return test::data::get_value();\n"
//"}\n"
//,fail),
//
//// Pointer-to-pointer with member functions
//t(
//"struct wrapper {\n"
//"    let ptr: i32* = {};\n"
//"    fn set_ptr(p: i32*) -> void { ptr = p; }\n"
//"    fn get_ptr_ptr() -> i32**;\n"
//"    fn deref_twice() -> i32 { return **get_ptr_ptr(); }\n"
//"};\n"
//"fn wrapper::get_ptr_ptr() -> i32** { return &ptr; }\n"
//"fn main() -> i32 {\n"
//"    let x: i32 = 100;\n"
//"    let w: wrapper = {};\n"
//"    w.set_ptr(&x);\n"
//"    let ptr_ptr: i32** = w.get_ptr_ptr();\n"
//"    **ptr_ptr = 200;\n"
//"    return w.deref_twice();\n"
//"}\n"
//,pass)
