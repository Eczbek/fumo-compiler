t(
"struct foo {\n"
"    let x: i32 = 123;\n"
"};\n"
"fn main() -> i32 {\n"
"    let var = foo{69};\n"
"    return var.x;\n"
"}\n"
,pass),
// Basic member function with implicit 'this' access
t(
"struct point {\n"
"    let x: i32 = 0;\n"
"    let y: i32 = 0;\n"
"    fn get_y() -> i32 { return y; }  // will access x implicitly\n"
"};\n"
"fn main() -> i32 {\n"
"    let p: point = {10, 69};\n"
"    let result: i32 = p.get_y();\n"
"    return result;\n"
"}\n"
,pass),
// Member function calling another member function
t(
"struct calculator {\n"
"    let value: i32 = 0;\n"
"    fn get_value() -> i32;\n"
"    fn double() -> i32;  // will call get_value() implicitly\n"
"};\n"
"fn calculator::get_value() -> i32 { return value; }\n"
"fn calculator::double() -> i32 {\n"
"    return get_value() * 2;\n"
"}\n"
"fn main() -> i32 {\n"
"    let calc: calculator = {34};\n"
"    let result: i32 = calc.double();\n"
"    return result + 1;\n"
"}\n"
,pass),
// Member function modifying member variable
//t(
//"struct counter {\n"
//"    let count: i32 = 0;\n"
//"    fn increment() -> i32;  // will modify count implicitly\n"
//"    fn get_count() -> i32;\n"
//"};\n"
//"fn counter::increment() -> i32 {\n"
//"    count = count + 1;\n"
//"    return count;\n // stops working if this function returns void for some reason"
//"}\n"
//"fn counter::get_count() -> i32 { return count; }\n"
//"fn main() -> void {\n"
//"    let c: counter = {0};\n"
//"    c.increment();\n"
//"    let result: i32 = c.get_count();\n"
//"}\n"
//,pass),
//// Member function with no return value used
//t(
//"struct logger {\n"
//"    let message: i32 = 0;\n"
//"    fn set_message(msg: i32) -> void;  // modifies message implicitly\n"
//"    fn log() -> void;  // side effects only\n"
//"};\n"
//"fn logger::set_message(msg: i32) -> void { message = msg; }\n"
//"fn logger::log() -> void {}\n"
//"fn main() -> void {\n"
//"    let logger: logger = {};\n"
//"    logger.set_message(42);\n"
//"    logger.log();\n"
//"}\n"
//,pass),
//// Invalid: accessing member without instance
//t(
//"struct test {\n"
//"    let value: i32 = 0;\n"
//"    fn get_value() -> i32;  // needs instance to access value\n"
//"};\n"
//"fn test::get_value() -> i32 { return value; }\n"
//"fn main() -> void {\n"
//"    let x: i32 = test::get_value();\n"
//"}\n"
//,fail),
//// Nested struct member access
//t(
//"struct inner {\n"
//"    let data: i32 = 0;\n"
//"    fn get_data() -> i32;  // returns data implicitly\n"
//"};\n"
//"struct outer {\n"
//"    let inner: inner = {};\n"
//"    fn get_inner_data() -> i32;  // accesses inner.get_data()\n"
//"};\n"
//"fn inner::get_data() -> i32 { return data; }\n"
//"fn outer::get_inner_data() -> i32 {\n"
//"    return inner.get_data();\n"
//"}\n"
//"fn main() -> void {\n"
//"    let outer: outer = {{5}};\n"
//"    let result: i32 = outer.get_inner_data();\n"
//"}\n"
//,pass),
//// Member function returning pointer
//t(
//"struct node {\n"
//"    let value: i32 = 0;\n"
//"    let next = node** {};\n"
//"    fn get_next() -> node*;  // returns next pointer\n"
//"};\n"
//"fn node::get_next() -> node* { return next; }\n"
//"fn main() -> void {\n"
//"    let node: node = {42};\n"
//"    let next_ptr: node* = node.get_next();\n"
//"}\n"
//,pass),
//// Invalid: member function on temporary
//t(
//"struct factory {\n"
//"    fn create() -> factory;  // returns by value\n"
//"    fn process() -> i32;  // can't call on temporary\n"
//"};\n"
//"fn factory::create() -> factory { return factory{}; }\n"
//"fn factory::process() -> i32 { return 42; }\n"
//"fn main() -> void {\n"
//"    let result: i32 = factory::create().process();\n"
//"}\n"
//,fail)
